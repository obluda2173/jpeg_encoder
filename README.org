#+title: Readme
#+author: Erik An
#+email: obluda2173@gmail.com
#+date: <2025-12-04>
#+lastmod: <2025-12-04 21:58>
#+options: num:t
#+startup: overview

* On this project
This project is a naive (unoptimised) JPEG encoder implemented in Julia.

The project aim is to deepen my understanding of the *Discrete Cosine Transformation (DCT)*, which is part of my Linear Algebra course.

*Note:* This project is not a university assignment in any way; it is a self-directed educational implementation to understand the mathematics behind image compression.

* Most interesting
The core of this project is the implementation of the *1-Dimensional DCT formula*.

While libraries exist to do this, this project implements the raw summation manually to understand the frequency decomposition:

$$C(u) = \alpha(u) \sum_{x=0}^{N-1}f(x)\cos\left[\dfrac{\pi(2x+1)u}{2N}\right]$$

*Note.* Formula looks incorrect near the sum symbol, blame github latex render, it's actually valid.

Where:
- $u$: The frequency index (which wave pattern we are checking).
- $N$: The total number of samples (e.g., 8).
- $f(x)$: The input signal (pixel value at spot $x$).
- $\cos[...]$: The cosine wave "ingredient."
- $\sum$: The sum (we multiply the input by the wave and sum it up to check for similarity).
- $\alpha(u)$: The normalization factor (Scaling factor).

* Steps for project
The pipeline follows the standard JPEG compression algorithm (excluding the final Huffman entropy coding):

1. *Preprocessing (Utils.jl)*:
   - Pad the image so dimensions are multiples of 8.
   - Slice the image into $8 \times 8$ pixel blocks.
   - Center pixel values (subtract 128) to shift range from $[0, 255]$ to $[-128, 127]$.

2. *Transformation (Transform.jl)*:
   - Apply Forward 2D DCT to every block (Separable approach: Rows then Columns).
   - Convert spatial data to frequency coefficients.

3. *Quantization (Quantization.jl)*:
   - Divide DCT coefficients by the standard JPEG Luminance Table.
   - Round to integers. *This is where the lossy compression and file size reduction happens.*

4. *Reconstruction (Main.jl)*:
   - Apply De-quantization and Inverse DCT (IDCT) to reconstruct the image and visualize artifacts.

* Project Structure
#+BEGIN_EXAMPLE
.
├── data
│   ├── input
│   │   └── test_1.jpg
│   └── output
│       └── test_1_compressed.jpg
├── derivations
│   ├── derivations.org
│   └── derivations.pdf
├── LICENSE
├── main.jl
├── README.org
└── src
    ├── Quantization.jl   # Luminance tables and division logic
    ├── Transform.jl      # DCT/IDCT Math implementation
    └── Utils.jl          # Image padding and slicing helpers
#+END_EXAMPLE

* Usage
To run the encoder, ensure you have the required Julia packages (~Images~, ~FileIO~, ~ImageIO~):

#+BEGIN_SRC bash
julia main.jl
#+END_SRC

*Note!* In the main.jl's last line, last argument stands for the quality scale of the output image. The higher scale value is, the less quality image has.

* Demonstration
Below you can see the working example of DCT compression:

- Original (16kb):

  [[data/input/test_1.jpg]]

- Compressed (12kb):

  [[data/output/test_1_compressed.jpg]]

* Important!
Note that this is a naive JPEG encoder. Thus it is not optimised. The goal of this project was again to deepen my understanding of DCT, at which I succeeded.
